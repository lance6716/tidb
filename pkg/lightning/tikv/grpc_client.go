// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tikv

import (
	"context"
	"encoding/binary"

	"github.com/google/uuid"
	"github.com/pingcap/errors"
	"github.com/pingcap/kvproto/pkg/import_sstpb"
	"github.com/pingcap/kvproto/pkg/kvrpcpb"
	"github.com/pingcap/tidb/pkg/util/codec"
	pd "github.com/tikv/pd/client"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// write2ImportService4Test writes these sorted key-value pairs to the TiKV
// cluster. SST files are generated by TiKV and saved in import directory if no
// error happens.
func write2ImportService4Test(
	ctx context.Context,
	pdAddrs []string,
	sortedKVs [][2][]byte,
	ts uint64,
) ([]*import_sstpb.SSTMeta, error) {
	pdClient, err := pd.NewClient(pdAddrs, pd.SecurityOption{})
	if err != nil {
		return nil, errors.Trace(err)
	}
	defer pdClient.Close()

	r0, err := pdClient.GetRegion(ctx, sortedKVs[0][0])
	if err != nil {
		return nil, errors.Trace(err)
	}
	r1, err := pdClient.GetRegion(ctx, sortedKVs[len(sortedKVs)-1][0])
	if err != nil {
		return nil, errors.Trace(err)
	}
	if r0.Meta.Id != r1.Meta.Id {
		return nil, errors.Errorf(
			"only support write to the same region, "+
				"first key: %X, last key: %X, "+
				"first region id: %d, last region id: %d",
			sortedKVs[0][0], sortedKVs[len(sortedKVs)-1][0],
			r0.Meta.Id, r1.Meta.Id,
		)
	}

	store, err := pdClient.GetStore(ctx, r0.Leader.GetStoreId())
	if err != nil {
		return nil, errors.Trace(err)
	}
	conn, err := grpc.DialContext(
		ctx, store.GetAddress(),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(),
	)
	if err != nil {
		return nil, errors.Trace(err)
	}
	defer conn.Close()

	ingestClient := import_sstpb.NewImportSSTClient(conn)
	writeStream, err := ingestClient.Write(ctx)
	if err != nil {
		return nil, errors.Trace(err)
	}
	u := uuid.New()
	writeMeta := &import_sstpb.SSTMeta{
		Uuid:        u[:],
		RegionId:    r0.Meta.Id,
		RegionEpoch: r0.Meta.RegionEpoch,
		Range: &import_sstpb.Range{
			Start: sortedKVs[0][0],
			End:   sortedKVs[len(sortedKVs)-1][0],
		},
	}
	rpcCtx := kvrpcpb.Context{
		RegionId:    r0.Meta.Id,
		RegionEpoch: r0.Meta.RegionEpoch,
		Peer:        r0.Leader,
	}
	err = writeStream.Send(&import_sstpb.WriteRequest{
		Chunk:   &import_sstpb.WriteRequest_Meta{Meta: writeMeta},
		Context: &rpcCtx,
	})
	if err != nil {
		return nil, errors.Trace(err)
	}

	batch := &import_sstpb.WriteBatch{
		CommitTs: ts,
		Pairs:    make([]*import_sstpb.Pair, 0, len(sortedKVs)),
	}
	for _, kv := range sortedKVs {
		batch.Pairs = append(batch.Pairs, &import_sstpb.Pair{
			Key:   kv[0],
			Value: kv[1],
		})
	}
	err = writeStream.Send(&import_sstpb.WriteRequest{
		Chunk:   &import_sstpb.WriteRequest_Batch{Batch: batch},
		Context: &rpcCtx,
	})
	if err != nil {
		return nil, errors.Trace(err)
	}
	resp, err := writeStream.CloseAndRecv()
	if err != nil {
		return nil, errors.Trace(err)
	}
	if resp.GetError() != nil {
		return nil, errors.Errorf("write failed: %s", resp.GetError())
	}
	return resp.Metas, nil
}

func isShortValue(val []byte) bool {
	return len(val) <= 255
}

func encodeWriteBatch2KV(batch *import_sstpb.WriteBatch) [][2][]byte {
	ts := batch.CommitTs
	kvs := make([][2][]byte, 0, len(batch.Pairs))
	for _, pair := range batch.Pairs {
		keyWithTS := []byte{'z'}
		keyWithTS = codec.EncodeBytes(keyWithTS, pair.Key)
		keyWithTS = binary.BigEndian.AppendUint64(keyWithTS, ^ts)
		if isShortValue(pair.Value) {
			// put flag
			val := append([]byte{}, 'P')
			val = binary.AppendUvarint(val, ts)
			// short value flag
			val = append(val, 'v')
			val = append(val, byte(len(pair.Value)))
			val = append(val, pair.Value...)

			kvs = append(kvs, [2][]byte{keyWithTS, val})
		} else {
			panic("not implemented, need to write to default CF")
		}
	}
	return kvs
}

func encodeKVs4Test(
	sortedKVs [][2][]byte,
	ts uint64,
) [][2][]byte {
	batch := &import_sstpb.WriteBatch{
		CommitTs: ts,
		Pairs:    make([]*import_sstpb.Pair, 0, len(sortedKVs)),
	}
	for _, kv := range sortedKVs {
		batch.Pairs = append(batch.Pairs, &import_sstpb.Pair{
			Key:   kv[0],
			Value: kv[1],
		})
	}

	return encodeWriteBatch2KV(batch)
}
